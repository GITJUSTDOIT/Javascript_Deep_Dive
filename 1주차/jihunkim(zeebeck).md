## 1장

#### 1.1 프로그래밍이란?

프로그래밍: 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션

#### 1.2 프로그래밍 언어

프로그래밍 언어는 구문(syntax)과 의미(semantics)의 조합으로 표현된다.

#### 1.3 구문과 의미

```javascript
const number = 'string';
console.log(number * number); // NaN
```

자바스크립트의 변수에는 어떠한 타입의 값도 할당할 수가 있는데, 위 코드는 문법(syntax)적으로 전혀 문제가 없지만 의미(semantics)는 없다. 그렇기에 number라는 이름의 변수에는 숫자를 할당하는 것이 의미적으로 옳다.

결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.



## 2장

#### 2.1 자바스크립트의 탄생

넷스케이프 커뮤니케이션즈(Netscape communications)의 브랜던 아이크(Brendan Eich)에 의해 개발되었으며, 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어

#### 2.2 자바스크립트의 표준화

마이크로소프트사의 자바스크립트 파생 버전인 Jscript등과 같은 언어와 호환되지 않아 여러 기능들이 자사 브라우저에서만 동작하는 문제등으로 인해 자바스크립트 기술의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화가 필요하게 되어 비영리 표준화 기구의 ECMA 인터내셔널에 자바스크립트의 표준화를 요청, 이후 EcmaScript를 통한 버전별 기능과 표준화가 정립

#### 2.3 자바스크립트 성장의 역사

초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로만 사용 됨, 이 시기에 대부분의 로직은 주로 웹 서버에서 실행되었고, 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었음

> 렌더링(rendering)
>
> 렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말한다. 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR: Server Side Rendering)을 가리키기도 한다.

#### 2.3.1 Ajax

1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기(asynchronous) 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous Javascript and XML)가 XMLHttpRequest라는 이름으로 등장함

> 이전의 웹페이지는  html 태그로 시작해서 html 태그로 끝나는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작했다. 그렇기 때문에 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링했다. 
>
> 이러한 방식은 변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문에 불필요한 데이터 통신이 발생하고, 변경할 필요가 없는 부분까지 처음부터 다시 렌더링해야 하기 때문에 성능 면에서도 불리하다. 이로 인해 화면이 전환되면 화면이 순간적으로 깜박이는 현상이 발생하고, 이는 웹페이지의 어쩔 수 없는 한계로 받아들어졌다.
>
> Ajax의 등장은 이전의 패러다임을 획기적으로 전환했다. 즉, 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해진 것이다. 이로써 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 성능과 부드러운 화면전환이 가능해졌다.

#### 2.3.2 jQuery

2006년, jQuery라는 라이브러리 등장으로 인해 다소 번거롭고 논란이 일던 DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었다. 

#### 2.3.3 V8 자바스크립트 엔진

2008년 등장한 구글의 V8 자바스크립트 엔진으로 인해 데스크톱 애플리케이션과 유사한 사용자 경험(UX: user experience)을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 정착하게 되었다. 또한 해당 엔진으로 인해 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동했고, 이는 웹 애플리케이션 개발에서 프런트엔드 영역이 주목받는 계기로 작용했다. 

#### 2.3.4 Node.js

2009년, 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다. 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다. 

#### 2.3.5 SPA 프레임워크

CBd(Component based development)방법론을 기반으로 하는 SPA(Single Page Application)가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA 기반의 프레임워크/라이브러리가 생겨났다.

#### 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. 

#### 2.5 자바스크립트의 특징

자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 또한 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다. 대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다. 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화한다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 더욱 빠르게 코드를 실행할 수 있다.

#### 2.6 ES6 브라우저 지원 현황

거의 모든 웹브라우저에서 지원하며, 혹시라도 브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나 IE나 구형 브라우저를 고려해야하는 말도안되는 상황이라면 바벨(Babel)과 같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 ES5 이하의 사양으로 다운그레이드할 필요가 있다. 

## 3장

#### 3.1 자바스크립트 실행 환경

브라우저 환경 또는 Node.js 환경에서 실행할 수 있으며, 기본적으로 브라우저에서 동작하는 코드는 Node.js 환경에서도 동일하게 동작한다. 그런데 한가지 주의해야 할 점은 브라우저와 Node.js는 용도가 다르다는 것인데, 브라우저는 HTML, CSS, 자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적이지만 Node.js는 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주된 목적이다. 따라서 브라우저와 Node.js 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 브라우저와 Node.js에서 ECMAScript  이외에 추가로 제공하는 기능은 호환되지 않는다.

> 브라우저는 파싱된 HTML 요소를 선택하거나 조작하는 기능의 집합인 DOM API를 기본적으로 제공한다. 
>
> 하지만 브라우저 외부에서 자바스크립트 개발 환경을 제공하는 것이 주 목적인 Node.js는 DOM API를 제공하지 않는다. 브라우저 외부 환경에서는 HTML 요소를 파싱해서 객체화한 DOM을 직접 다룰 필요가 없기 때문이다.

> 웹 크롤링
>
> 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML 문서를 가져온 다음, 이름 가공해서 필요한 데이터만 추출하는 경우가 있는데 이를 웹 크롤링(web crawling)이라 한다. 서버 환경은  DOM API를 제공하지 않으므로 cheerio 같은 DOM 라이브러리를 사용해 HTML 문서를 가공하기도 한다.

#### 3.2 웹 브라우저

다양한 웹 브라우저가 있지만 크롬 브라우저가 전세계적으로 가장 많이 사용하는 브라우저이며 V8 자바스크립트 엔진을 사용한다.

#### 3.2.1 개발자 도구

개발자 도구는 대부분의 브라우저에 기본 내장되어 있으므로 별도로 설치할 필요가 없다.

>| 패널        | 설명                                                         |
>| ----------- | ------------------------------------------------------------ |
>| Elements    | 로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해 볼 수 있다. 단, 편집한 내용이 저장되지는 않는다. 웹페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인해 유용한 힌트를 얻을 수 있다. |
>| Console     | 로딩된 웹페이지의 에러를 확인하거나 자바스크립트 소스코드에 작성한 console.log 메서드의 실행결과를 확인할 수 있다. |
>| Sources     | 로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있다.      |
>| Network     | 로딩된 웹페이지에 관련된 네트워크 요청(request) 정보와 성능을 확인할 수 있다. |
>| Application | 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.           |



#### 3.2.2 콘솔

개발자 도구의 Console 패널은 자바스크립트 코드에서 에러가 발생히 애플리케이션이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳이다. 구현 단계에서는 에러가 빈번하게 발생하므로 항상 콘솔을 열어둔 상태에서 개발하는 것이 좋다. 

자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있는 REPL(Read Eval Print Loop: 입력 수행 출력 반복) 환경으로 사용할 수도 있다.

#### 3.2.3 브라우저에서 자바스크립트 실행

브라우저는 HTML 파일을 로드하면 script 태그에 포함된 자바스크립트 코드를 실행하는데 자바스크립트 코드 내에 console.log 메서드가 호출되었다면 콘솔에 실행 결과가 출력될 것이다.

#### 3.2.4 디버깅

개발자 도구 기능 중 자바스크립트 코드를 디버깅할 수 있는 Sources 패널을 통해 사용할 수 있다.

#### 3.3 Node.js

클라이언트 사이드, 즉 브라우저에서 동작하는 간단한 웹 애플리케이션은 브라우저만으로도 개발할 수 있다.

#### 3.4 비주얼 스튜디오 코드

Microsoft사에서 만든 코드 에디터이며, 수많은 개발 플러그인을 통해 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다.

## 4장

#### 4.1 변수란 무엇인가? 왜 필요한가?

변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간략하게 값의 위치를 가리키는 상징적인 이름이다.

#### 4.2 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 

#### 4.3 변수 선언

변수를 생성하는 것을 말하며, 좀 더 자세하게 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.

변수를 사용하려면 반드시 선언이 필요하며, 변수를 선언할 때는 var, let, const 키워드를 사용한다.

> **ES5 vs ES6**
>
> var 키워드는 여러 단점이 있다. var 키워드의 여러 단점 중에서 가장 대표적인 것이 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것인데, 이로 인해 의도체 않게 전역 변수가 선언되어 심각한 부작용이 발생된다.
>
> ES6에서 let과 const 키워드를 도입한 이유는 var 키워드의 여러 단점을 보완하기 위해서다. 따라서 let과 const 키워드가 도입된 이유를 정확히 파악하려면 먼저 var 키워드의 단점부터 정확히 이해해야 한다. var 키워드의 단점을 이해하려면 먼저 스코프와 같은 자바스크립트의 핵심 개념을 먼저 살펴봐야 한다.
>
> ES6에서 let과 const 키워드가 도입되었다고 해서 var 키워드가 폐기 된 것은 아니다. ES6 이전 사양으로 작성된 코드는 var 키워드를 사용해 구현되어 있을 것이며, ES6 이후 사양을 따른다 하더라도 권장하지는 않지만 var 키워드를 사용할 수도 있다.
>
> ES5와 ES6는 서로 상관없는 별개의 사양이 아니다. ES6 이전 사양으로 구현된 코드는 ES6 기반의 자바스크립트 엔진에서 모두 정상적으로 동작한다. 즉, ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것이다. 다시 말해, ES6는 ES5의 상위 집합이다.
>
> 따라서 ES6 사양을 기준으로 자바스크립트를 학습한다 하더라도 ES5 사양을 잘 알아둘 필요가 있다. ES5를 잘 이해하고 있으면 ES6를 더욱 빠르고 명확하게 이해할 수 있기 때문이다.

> **키워드** 
>
> 키워드는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어, var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다. 

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

* 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
* 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

#### 4.4 변수 선언의 실행 시점과 변수 호이스팅

변수 호이스팅: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

#### 4.5 값의 할당

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.

#### 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 의미하며, var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 하는 것이다. 만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 있다면 변수가 아니라 상수라고 한다. 상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한번만 할당할 수 있는 변수다.

> **가비지 콜렉터(garbage collector)**
>
> 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.

#### 4.7 식별자 네이밍 규칙

식별자: 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 의미 

* 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
* 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
* 예약어는 식별자로 사용할 수 없다.

자바스크립트에서는 일반적으로 변수나 함수의 이름에는 **카멜 케이스**를 사용하며, 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 사용한다.

## 5장 

#### 5.1 값

값은 식(표현식)이 평가되어 생성된 결과를 말한다. 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 

#### 5.2 리터럴

**리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.**

#### 5.3 표현식

표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

```javascript
var score= 100; // 100은 리터럴이다. 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴은 그 자체로 표현식이다.

var score= 50 + 50; // 50 + 50은 리터럴과 연산자로 이뤄져 있다. 하지만 50 + 50도 평가되어 숫자 값 100을 생성하므로 표현식이다.

score; // 100;  변수 식별자를 참조하면 변수 값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다. 
```

이처럼 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다. 다음과 같이 다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동일하다. 즉, **값으로 평가될 수 있는 문은 모두 표현식이다.**

#### 5.4 문

문과 표현식을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 된다. 이는 버그를 줄이고 코드의 품질을 높여줄 것이다. 따라서 반드시 문과 표현식은 확실히 이해할 필요가 있다.

**문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.** 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성되며, 여기서 **토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.** 예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.

#### 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론(;)은 문의 종료를 나타낸다. 즉, 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 따라서 문을 끝낼 때는 세미콜론을 붙여야 한다. 단, 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 

예를 들어, if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문이다. 문의 끝에 붙이는 세미콜론은 옵션이다. 즉, 세미콜론은 생략 가능하다. 이는 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI: automatic semicolon insertion)이 암묵적으로 수행되기 때문이다. 

하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 있다. 그렇기 때문에 대다수의 주장은 세미콜론을 붙여라이다.

#### 5.6 표현식인 무과 표현식이 아닌 문

문(statement)에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를 들어, 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다.

**표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.** 

표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다. 하지만 표현식이 아닌 문은 값으로 평가할 수 없기때문에 변수에 할당하면 에러가 발생한다.

```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
```

> 완료 값(completion value)
>
> 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료 값이라고 한다. 완료 값은 표현식의 평가가 아니다. 그렇기 때문에 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

## 6장

### 데이터 타입

데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다.

자바스크립트(ES6 기준)는 8개의 데이터 타입을 제공한다. 8개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다.

|     구분      |       데이터 타입       |                             설명                             |
| :-----------: | :---------------------: | :----------------------------------------------------------: |
| **원시 타입** |         Number          |     숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재      |
|               |         BigInt          | Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 253 - 1보다 큰 정수를 표현할 수 있는 내장 객체 |
|               |         String          |                            문자열                            |
|               |         Boolean         |                논리적 참(true)과 거짓(false)                 |
|               |        Undefined        |      var 키워드로 선언된 변수에 암묵적으로 할당되는 값       |
|               |          Null           |      값이 없다는 것을 의도적으로 명시할 때 사용하는 값       |
|               |         Symbol          |                  ES 6에서 추가된 7번째 타입                  |
| **객체 타입** | Object, Function, Array |                     객체, 함수, 배열 등                      |



#### 6.1 숫자 타입

ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다. 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

```
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다고 했다. 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

```javascript
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5
```

숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다. 

#### 6.2 문자열 타입

문자열타입은 텍스트 데이터를 나타내는 데 사용한다. 그리고 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.

문자열은 작은따옴표(' '), 큰따옴표(" ") 또는 백틱(\`` )으로 텍스트를 감싼다. **자바스크립트에서 가장 일반적인 표기법은 작은따옴표를 사용하는 것이다.**

```javascript
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱(ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";

// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

#### 6.3 템플릿 리터럴

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 테그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 그리고 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

```javascript
var template = `Template literal`;
console.log(template); // Template literal

//멀티라인 문자열
var str = 'Hello
world.'; // SyntaxError: invalid or unexpected token.
```

> 개행문자는 텍스트의 한 줄이 끝남을 표시하는 문자 또는 문자열이다. 개행 문자에는 라인 피드와 캐리지 리턴이 있다. 이는 과거 타자기에서 커서를 제어하는 방식에서 비롯된 것인데. 라인 피드(\n)는 커서를 정지한 상태에서 종이를 한 줄 올리는 것이고, 캐리지 리턴(\r)은 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것이다. 초창기 컴퓨터는 출력을 프린터로 수행했는데, 이 때 개행을 위해 라인 피드와 캐리지 리턴을 모두 사용했다. 즉 CRLF(\r\n)로 커서를 맨 앞으로 이동시키고 종이를 한 줄 올리는 방식으로 개행했다.
>
> 현대의 컴퓨터 운영체제는 서로 다른 체계의 개행 방식을 사용한다. 윈도우는CR+LF로 새 줄을 나타내고 유닉스는 LF로 새 줄을 나타낸다. macOS에서는 버전 9까지 CR로 새줄을 나타냈지만 버전 10부터 LF를 사용한다. 따라서 다른 운영체제에서 작성한 텍스트 파일은 서로 개행 문자를 인식하지 못한다. 다만 대부분의 텍스트 에디터는 운영체제에 맞게 개행 문자를 자동으로 변환해주므로 큰 문제는 없다. 자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)으로 개행하는 경우는 거의 없고 일반적으로 라인 파드(\n)를 사용해 개행한다.

#### 6.4 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다.

#### 6.5 undefined 타입

undefined 타입의 값은 undefinded가 유일하다. **undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.** 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적이 없는, 즉 초기화되지 않은 변수라는 것을 간파할 수 있다.

자바스크립트 엔진이 변수를 초기화하는 데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면, undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다.

**그렇다면 변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까? 그런 경우에는 undefined를 할당하는 것이 아니라 null을 할당한다.**

> 선언(declaration)과 정의(definition)
>
> undefined를 직역하면 "정의되지 않은"이다. 일반적으로 정의란 개념은 어떤 대상을 명확하게 규정하는 것을 의미한다. 자바스크립트의 undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것을 말한다.
>
> 다른 프로그래밍 언어에서는 선언과 정의를 엄격하게 구분해서 사용하는 경우가 있다. 예를 들어, C에서 선언과 정의는 "실제로 메모리 주소를 할당하는가"로 구분한다. 단순히 컴파일러에게 식별자의 존재만 알리는 것은 선언이고, 실제로 컴파일러가 변수를 생성해서 식별자와 메모리 주소가 연결되면 정의로 구분한다. 자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이뤄지기 때무에 선언과 정의의 구분이 모호하다.
>
> ECMAScript 사양에서 변수는 "선언한다"라고 표현하고, 함수는 "정의한다"라고 표현한다. 



#### 6.6 null 타입

null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.

프로그래밍 언어에서 null은 변수에 null이 없다는 것을 의도적으로 명시할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다. 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

#### 6.7 심벌 타입

심벌은 ES6에서 추가된 타입으로 변경 불가능한 원시 타입의 값이다. 그리고 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 이 때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

//이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```

#### 6.8 객체 타입

**자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.** 

#### 6.9 데이터 타입의 필요성

##### 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 한다. 다시 말해 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다. 

```javascript
var score = 100;
```

위 코드가 실행되면 컴퓨터는 숫자 값 100을 저장하기 위해 

1. 메모리 공간을 확보한다.

2. 확보된 메모리에 숫자 값 100을 2진수로 저장한다. 이러한 처리를 하려면 숫자 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 한다. 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
3. 위 코드의 경우, 자바스크립트 엔진은 리터럴 100을 숫자타입의 값으로 해석하고 숫자 타입의 값 100을 저장하기 위해 8바이트의 메모리 공간을 확보한다. 그리고 100을 2진수로 저장한다.

> **데이터 타입에 따라 확보되는 메모리 공간의 크기**
>
> ECMAScript 사양은 문자열과 숫자 타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지는 않다. 따라서 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간의 크기는 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다. 단, ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 명시되어 있고, 배정밀도 64비트 부동소수점형식은 8바이트로 숫자를 표현하므로 이 책에서는 숫자 값의 크기를 8바이트로 설명한다.



값을 참조하는 경우는, 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다. 정확히 말하면 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다.

당연히 이때 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다. score 변수의 경우, 저장되어 있는 값이 숫자 타입이므로 8바이트 단위로 읽어 들이지 않으면 값이 훼손된다. 



#### 6.10 동적 타이핑

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다. 자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const  키워드를 사용해 변수를 선언할 뿐이다. 

**자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론: type inference)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.** 이러한 특징을 동적 타이핑이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라 한다.

**변수는 타입을 가질까? 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다. 변수는 값이 묶여 있는 값에 대한 별명이기 때문이다.**

## 7장

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이 때 연산의 대상을 피연산자라한다. 

```javascript
// 산술 연산자
5 * 4 // -> 20

// 문자열 연결 연산자
'My name is ' + 'Lee' // -> 'My name is Lee'

// 비교 연산자
 3 > 5 // -> false
 
 // 논리 연산자
 true && false // -> false
 
 // 타입 연산자
 typeof 'Hi' // -> string
```

## 8장

제어문은 조건에 따라 코드 블록을 실행 하거나 반복 실행할 대 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

#### 8.1 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다. 

```javascript
{
	var foo = 10;
}
```

#### 8.2 조건문

조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 자바스크립트에서는 if..else 문과 switch 문으로 두 가지 조건문을 제공한다.

```javascript
// if 문
if (조건식) {
	// 조건식이 참이면 이 코드 블록이 실행된다.
} else {
	// 조건식이 거짓이면 이 코드 블록이 실행된다.
}

// switch 문
switch (표현식){
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  case 표현식2:
   	switch 문의 표현식과 표현식2가 일치하면 실행될 문;
  default:
  	switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문'    
}
```

#### 8.3 반복문

반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.

자바스크립트는 세 가지 반복문인 for 문, while 문, do...while 문을 제공한다.

> **반복문을 대체할 수 있는 다양한 기능**
>
> 자바스크립트는 배열을 순회할 때 사용하는 forEach 메서드, 객체의 프로퍼티를 열거할 때 사용하는 for...in문. ES6에서 도입된 이터러블을 순회할 수 있는 for...of 문과 같이 반복문을 대체할 수 있는 다양한 기능을 제공한다.

```javascript
// for 문
for (var i = 0; i < 2; i++) {
	console.log(i);
}
// do...while 문
var count = 0;
do {
  console.log(count); // 0 1 2
  count++;
} while (count < 3);

// while 문
var count = 0;
while (count < 3) {
  console.log(count); // 0 1 2
  count++;
}
```

## 9장

자바스크립트의 모든 값은 타입이 있다. 값이 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값이 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅 이라고 한다.

또, 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 하는데 이를 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.

```javascript
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅한다.
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10

var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
var str = x + '';
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10
```



자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.  아래 값들은 falsy이다. Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.

* false, undefined, null, 0, -0, NaN, ''(빈 문자열)

  

## 10장

자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 "모든 것"이 객체이다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다.

> 자바스크립트의 객체는 함수와 밀접한 관계를 가진다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 하다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수 없는 개념이다. 즉, 객체를 이해해야 함수를 제대로 이해할 수 있고, 반대로 함수를 이해해야 객체를 정확히 이해할 수 있다.

> 인스턴스
>
> 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어다.



## 11장

자바스크립트가 제공하는 데이터 타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다. 데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유가 뭘까? 원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다.

* 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.
* 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
* 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라고 하며, 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라고 한다.

객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 잇다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 객체(참조) 타입의 값, 극 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉, 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.

> 얕은 복사와 깊은 복사
>
> 객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계 depth까지만 복사하는 것을 말하고, 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 의미한다.
>
> 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉, 원본과 복사복은 참조 값이 다른 별개의 객체다. 하지만 얉은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다는 차이가 있다. 참고로 다음과 같이 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.

