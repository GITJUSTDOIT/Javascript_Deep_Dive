## 1장

#### 1.1 프로그래밍이란?

프로그래밍: 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션

#### 1.2 프로그래밍 언어

프로그래밍 언어는 구문(syntax)과 의미(semantics)의 조합으로 표현된다.

#### 1.3 구문과 의미

```javascript
const number = 'string';
console.log(number * number); // NaN
```

자바스크립트의 변수에는 어떠한 타입의 값도 할당할 수가 있는데, 위 코드는 문법(syntax)적으로 전혀 문제가 없지만 의미(semantics)는 없다. 그렇기에 number라는 이름의 변수에는 숫자를 할당하는 것이 의미적으로 옳다.

결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.



## 2장

#### 2.1 자바스크립트의 탄생

넷스케이프 커뮤니케이션즈(Netscape communications)의 브랜던 아이크(Brendan Eich)에 의해 개발되었으며, 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어

#### 2.2 자바스크립트의 표준화

마이크로소프트사의 자바스크립트 파생 버전인 Jscript등과 같은 언어와 호환되지 않아 여러 기능들이 자사 브라우저에서만 동작하는 문제등으로 인해 자바스크립트 기술의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화가 필요하게 되어 비영리 표준화 기구의 ECMA 인터내셔널에 자바스크립트의 표준화를 요청, 이후 EcmaScript를 통한 버전별 기능과 표준화가 정립

#### 2.3 자바스크립트 성장의 역사

초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로만 사용 됨, 이 시기에 대부분의 로직은 주로 웹 서버에서 실행되었고, 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었음

> 렌더링(rendering)
>
> 렌더링이란 HTML, CSS, 자바스크립트로 작성된 문서를 해석해서 브라우저에 시각적으로 출력하는 것을 말한다. 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR: Server Side Rendering)을 가리키기도 한다.

#### 2.3.1 Ajax

1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기(asynchronous) 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous Javascript and XML)가 XMLHttpRequest라는 이름으로 등장함

> 이전의 웹페이지는  html 태그로 시작해서 html 태그로 끝나는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 동작했다. 그렇기 때문에 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링했다. 
>
> 이러한 방식은 변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문에 불필요한 데이터 통신이 발생하고, 변경할 필요가 없는 부분까지 처음부터 다시 렌더링해야 하기 때문에 성능 면에서도 불리하다. 이로 인해 화면이 전환되면 화면이 순간적으로 깜박이는 현상이 발생하고, 이는 웹페이지의 어쩔 수 없는 한계로 받아들어졌다.
>
> Ajax의 등장은 이전의 패러다임을 획기적으로 전환했다. 즉, 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해진 것이다. 이로써 웹 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 성능과 부드러운 화면전환이 가능해졌다.

#### 2.3.2 jQuery

2006년, jQuery라는 라이브러리 등장으로 인해 다소 번거롭고 논란이 일던 DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었다. 

#### 2.3.3 V8 자바스크립트 엔진

2008년 등장한 구글의 V8 자바스크립트 엔진으로 인해 데스크톱 애플리케이션과 유사한 사용자 경험(UX: user experience)을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 정착하게 되었다. 또한 해당 엔진으로 인해 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동했고, 이는 웹 애플리케이션 개발에서 프런트엔드 영역이 주목받는 계기로 작용했다. 

#### 2.3.4 Node.js

2009년, 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다. 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다. 

#### 2.3.5 SPA 프레임워크

CBd(Component based development)방법론을 기반으로 하는 SPA(Single Page Application)가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA 기반의 프레임워크/라이브러리가 생겨났다.

#### 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. 

#### 2.5 자바스크립트의 특징

자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 또한 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다. 대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다. 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화한다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 더욱 빠르게 코드를 실행할 수 있다.

#### 2.6 ES6 브라우저 지원 현황

거의 모든 웹브라우저에서 지원하며, 혹시라도 브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나 IE나 구형 브라우저를 고려해야하는 말도안되는 상황이라면 바벨(Babel)과 같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 ES5 이하의 사양으로 다운그레이드할 필요가 있다. 

## 3장

#### 3.1 자바스크립트 실행 환경

브라우저 환경 또는 Node.js 환경에서 실행할 수 있으며, 기본적으로 브라우저에서 동작하는 코드는 Node.js 환경에서도 동일하게 동작한다. 그런데 한가지 주의해야 할 점은 브라우저와 Node.js는 용도가 다르다는 것인데, 브라우저는 HTML, CSS, 자바스크립트를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적이지만 Node.js는 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주된 목적이다. 따라서 브라우저와 Node.js 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 브라우저와 Node.js에서 ECMAScript  이외에 추가로 제공하는 기능은 호환되지 않는다.

> 브라우저는 파싱된 HTML 요소를 선택하거나 조작하는 기능의 집합인 DOM API를 기본적으로 제공한다. 
>
> 하지만 브라우저 외부에서 자바스크립트 개발 환경을 제공하는 것이 주 목적인 Node.js는 DOM API를 제공하지 않는다. 브라우저 외부 환경에서는 HTML 요소를 파싱해서 객체화한 DOM을 직접 다룰 필요가 없기 때문이다.

> 웹 크롤링
>
> 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML 문서를 가져온 다음, 이름 가공해서 필요한 데이터만 추출하는 경우가 있는데 이를 웹 크롤링(web crawling)이라 한다. 서버 환경은  DOM API를 제공하지 않으므로 cheerio 같은 DOM 라이브러리를 사용해 HTML 문서를 가공하기도 한다.

#### 3.2 웹 브라우저

다양한 웹 브라우저가 있지만 크롬 브라우저가 전세계적으로 가장 많이 사용하는 브라우저이며 V8 자바스크립트 엔진을 사용한다.

#### 3.2.1 개발자 도구

개발자 도구는 대부분의 브라우저에 기본 내장되어 있으므로 별도로 설치할 필요가 없다.

>| 패널        | 설명                                                         |
>| ----------- | ------------------------------------------------------------ |
>| Elements    | 로딩된 웹페이지의 DOM과 CSS를 편집해서 렌더링된 뷰를 확인해 볼 수 있다. 단, 편집한 내용이 저장되지는 않는다. 웹페이지가 의도된 대로 렌더링되지 않았다면 이 패널을 확인해 유용한 힌트를 얻을 수 있다. |
>| Console     | 로딩된 웹페이지의 에러를 확인하거나 자바스크립트 소스코드에 작성한 console.log 메서드의 실행결과를 확인할 수 있다. |
>| Sources     | 로딩된 웹페이지의 자바스크립트 코드를 디버깅할 수 있다.      |
>| Network     | 로딩된 웹페이지에 관련된 네트워크 요청(request) 정보와 성능을 확인할 수 있다. |
>| Application | 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다.           |



#### 3.2.2 콘솔

개발자 도구의 Console 패널은 자바스크립트 코드에서 에러가 발생히 애플리케이션이 정상적으로 동작하지 않을 때 가장 우선적으로 살펴봐야 할 곳이다. 구현 단계에서는 에러가 빈번하게 발생하므로 항상 콘솔을 열어둔 상태에서 개발하는 것이 좋다. 

자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있는 REPL(Read Eval Print Loop: 입력 수행 출력 반복) 환경으로 사용할 수도 있다.

#### 3.2.3 브라우저에서 자바스크립트 실행

브라우저는 HTML 파일을 로드하면 script 태그에 포함된 자바스크립트 코드를 실행하는데 자바스크립트 코드 내에 console.log 메서드가 호출되었다면 콘솔에 실행 결과가 출력될 것이다.

#### 3.2.4 디버깅

개발자 도구 기능 중 자바스크립트 코드를 디버깅할 수 있는 Sources 패널을 통해 사용할 수 있다.

#### 3.3 Node.js

클라이언트 사이드, 즉 브라우저에서 동작하는 간단한 웹 애플리케이션은 브라우저만으로도 개발할 수 있다.

#### 3.4 비주얼 스튜디오 코드

Microsoft사에서 만든 코드 에디터이며, 수많은 개발 플러그인을 통해 코드 자동 완성, 문법 오류 감지, 디버깅, Git 연동 등 강력하고 편리한 기능을 활용할 수 있다.

## 4장

#### 4.1 변수란 무엇인가? 왜 필요한가?

변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간략하게 값의 위치를 가리키는 상징적인 이름이다.

#### 4.2 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 

#### 4.3 변수 선언

변수를 생성하는 것을 말하며, 좀 더 자세하게 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.

변수를 사용하려면 반드시 선언이 필요하며, 변수를 선언할 때는 var, let, const 키워드를 사용한다.

> **ES5 vs ES6**
>
> var 키워드는 여러 단점이 있다. var 키워드의 여러 단점 중에서 가장 대표적인 것이 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것인데, 이로 인해 의도체 않게 전역 변수가 선언되어 심각한 부작용이 발생된다.
>
> ES6에서 let과 const 키워드를 도입한 이유는 var 키워드의 여러 단점을 보완하기 위해서다. 따라서 let과 const 키워드가 도입된 이유를 정확히 파악하려면 먼저 var 키워드의 단점부터 정확히 이해해야 한다. var 키워드의 단점을 이해하려면 먼저 스코프와 같은 자바스크립트의 핵심 개념을 먼저 살펴봐야 한다.
>
> ES6에서 let과 const 키워드가 도입되었다고 해서 var 키워드가 폐기 된 것은 아니다. ES6 이전 사양으로 작성된 코드는 var 키워드를 사용해 구현되어 있을 것이며, ES6 이후 사양을 따른다 하더라도 권장하지는 않지만 var 키워드를 사용할 수도 있다.
>
> ES5와 ES6는 서로 상관없는 별개의 사양이 아니다. ES6 이전 사양으로 구현된 코드는 ES6 기반의 자바스크립트 엔진에서 모두 정상적으로 동작한다. 즉, ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것이다. 다시 말해, ES6는 ES5의 상위 집합이다.
>
> 따라서 ES6 사양을 기준으로 자바스크립트를 학습한다 하더라도 ES5 사양을 잘 알아둘 필요가 있다. ES5를 잘 이해하고 있으면 ES6를 더욱 빠르고 명확하게 이해할 수 있기 때문이다.

> **키워드** 
>
> 키워드는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어, var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다. 

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

* 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
* 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

#### 4.4 변수 선언의 실행 시점과 변수 호이스팅

변수 호이스팅: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

#### 4.5 값의 할당

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.

#### 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 의미하며, var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 하는 것이다. 만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 있다면 변수가 아니라 상수라고 한다. 상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한번만 할당할 수 있는 변수다.

> **가비지 콜렉터(garbage collector)**
>
> 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.

#### 4.7 식별자 네이밍 규칙

식별자: 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 의미 

* 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
* 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
* 예약어는 식별자로 사용할 수 없다.

자바스크립트에서는 일반적으로 변수나 함수의 이름에는 **카멜 케이스**를 사용하며, 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 사용한다.

## 5장 

#### 5.1 값

값은 식(표현식)이 평가되어 생성된 결과를 말한다. 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 

#### 5.2 리터럴

**리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.**

#### 5.3 표현식

표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

```javascript
var score= 100; // 100은 리터럴이다. 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴은 그 자체로 표현식이다.

var score= 50 + 50; // 50 + 50은 리터럴과 연산자로 이뤄져 있다. 하지만 50 + 50도 평가되어 숫자 값 100을 생성하므로 표현식이다.

score; // 100;  변수 식별자를 참조하면 변수 값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다. 
```

이처럼 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다. 다음과 같이 다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동일하다. 즉, **값으로 평가될 수 있는 문은 모두 표현식이다.**

#### 5.4 문

문과 표현식을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 된다. 이는 버그를 줄이고 코드의 품질을 높여줄 것이다. 따라서 반드시 문과 표현식은 확실히 이해할 필요가 있다.

**문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.** 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성되며, 여기서 **토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.** 예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.

#### 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론(;)은 문의 종료를 나타낸다. 즉, 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 따라서 문을 끝낼 때는 세미콜론을 붙여야 한다. 단, 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 

예를 들어, if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 이러한 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문이다. 문의 끝에 붙이는 세미콜론은 옵션이다. 즉, 세미콜론은 생략 가능하다. 이는 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI: automatic semicolon insertion)이 암묵적으로 수행되기 때문이다. 

하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 있다. 그렇기 때문에 대다수의 주장은 세미콜론을 붙여라이다.

#### 5.6 표현식인 무과 표현식이 아닌 문

문(statement)에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를 들어, 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다.

**표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.** 

표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다. 하지만 표현식이 아닌 문은 값으로 평가할 수 없기때문에 변수에 할당하면 에러가 발생한다.

```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x;

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var
```

> 완료 값(completion value)
>
> 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료 값이라고 한다. 완료 값은 표현식의 평가가 아니다. 그렇기 때문에 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

